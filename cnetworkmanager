#! /usr/bin/python
# cnetworkmanager: Command Line Interface for NetworkManager
# by: http://en.opensuse.org/User:Mvidner
# license: http://www.gnu.org/licenses/gpl-2.0.html or later

VERSION = "0.8.4"
print "cnetworkmanager %s - Command Line Interface for NetworkManager" % VERSION

norpm = False
import sys
# find other modules in our prefix, if specified
if len(sys.argv) > 2 and sys.argv[1] == "--prefix":
    prefix = sys.argv[2]
    sys.argv[1:] = sys.argv[3:]
    sys.path.append(prefix + "/share/cnetworkmanager");

import os
import string
import re
import time
from optparse import OptionParser
try:
    import dbus
    import dbus.service
    import _dbus_bindings
except:
    print "Install python-1-dbus.rpm or or python-dbus.rpm or python-dbus.deb"
    norpm = True
try:
    import gobject
except:
    # todo - only if loop wanted
    print "Install python-gobject2.rpm or pygobject2.rpm or python-gobject.deb"
    norpm = True
# python-gnome.rpm has gconf for nm-applet...
if norpm:
    sys.exit(1)

from dbus.mainloop.glib import DBusGMainLoop
DBusGMainLoop(set_as_default=True)

# private modules:
from monitor import MonitorBase
from configparser_knm import ConfigParserKNM
from mkconmap import *
from util import *

from object import *
from manager import *
from manager06 import cNM_06
from manager07 import cNM_07
from device import cDevice
from device06 import cDevice_06
from device07 import cDevice_07
from ap import cAP
from ap06 import cAP_06
from ap07 import cAP_07
from applet import cApplet, SSC, USC, NMIC
from applet06 import cApplet_06

LOOP = False

bus = dbus.SystemBus()

# FOOC = connection (service) string
# FOOI = interface string
# fooo = object
# fooi = interface
# foopi = property interface
def introspect(obj):
    ii = dbus.Interface(obj, 'org.freedesktop.DBus.Introspectable')
    print ii.Introspect()

def make_nm(opath):
    "Detects NM version and chooses appropriate class"

    nmo = bus.get_object(NMC, opath)
    nmi = dbus.Interface(nmo, NMI)
    try:
        dummy = nmi.getDevices()
        return cNM_06(opath, options)
    except dbus.exceptions.DBusException, e:
        if e.get_dbus_name() == 'org.freedesktop.DBus.Error.AccessDenied':
           raise
        return cNM_07(opath, options)

def opath_validchar(c):
    # _ is also escaped even though it is valid
    return \
        string.ascii_letters.find(c) != -1 or \
        string.digits.find(c) != -1

def opath_escape(s):
    r = ""
    for c in s:
        # TODO find a more elegant way
        if not opath_validchar(c):
            # "-" -> "_2d_"
            c = "_%2x_" % ord(c)
        r = r + c
    return r

def opath_unescape(s):
    # "2d" -> "-"
    unhex = lambda xx: chr(eval("0x"+xx))
    # all "_2d_" -> "-"
    return re.sub("_.._", lambda p: unhex(p.group()[1:3]), s)

def dump_time(unixtime):
    return time.asctime(time.localtime(unixtime))

# server analog of cApplet
class UserSettings(dbus.service.Object):
    # conmaps is a list
    def __init__(self, opath, conmaps):
        dbus.service.Object.__init__(self, bus, opath)
        #print "CONMAPS:", conmaps
        self.conns = map(self.newCon, conmaps)

    def addCon(self, conmap):
        c = self.newCon(conmap)
        self.conns.append(c)
        return c

    counter = 1
    def newCon(self, conmap):
        cpath = "/MyConnection/%d" % self.counter
        self.counter = self.counter + 1
        c = Connection(cpath, conmap)
        self.NewConnection(cpath) # announce it
        return c

    @dbus.service.method(dbus_interface='org.freedesktop.NetworkManagerSettings',
                             in_signature='', out_signature='ao')
    def ListConnections(self):
        return [c.__dbus_object_path__ for c in self.conns]

    #this is for EMITTING a signal, not receiving it
    @dbus.service.signal(dbus_interface='org.freedesktop.NetworkManagerSettings',
                             signature='o')
    def NewConnection(self, opath):
        pass
        #print "signalling newconn:", opath

    def GetByNet(self, net_name):
        "Returns connection, or None"
        for c in self.conns:
            if c.isNet(net_name):
                return c
        return None


class UserSettings_06(UserSettings):
    # conmaps is a list
    def __init__(self, opath, conmaps):
        dbus.service.Object.__init__(self, bus, opath)
        #print "CONMAPS:", conmaps
        self.conns = map(self.newCon, conmaps)

    counter = 1
    def newCon(self, conmap):
        cpath = "/MyConnection/%d" % self.counter
        self.counter = self.counter + 1
        c = Connection_06(cpath, conmap)
        #self.NewConnection(cpath) # announce it
        return c

    @dbus.service.method(dbus_interface="org.freedesktop.NetworkManagerInfo",
                         in_signature="i", out_signature='as')
    def getNetworks(self, i):
        # FIXME bytearray to str WHERE?
        #n = [ssid_str(c.Ssid()) for c in self.conns]
        n = [c.ID() for c in self.conns]
        print "getNetworks:", n
        return n

    @dbus.service.method(dbus_interface="org.freedesktop.NetworkManagerInfo",
                         in_signature="", out_signature='ao') # out??
    def getVPNConnections(self):
        return []               # FIXME

    @dbus.service.method(dbus_interface="org.freedesktop.NetworkManagerInfo",
                         in_signature="si")
                         #out_signature='sibasi') #varies
    def getNetworkProperties(self, net, type):
        print "GNP", net
        # type is 1, NETWORK_TYPE_ALLOWED
        c = self.GetByNet(net)
        if c != None:
            return c.getNetworkProperties()
        print "Oops, could not getNetworkProperties for " + net
        

    @dbus.service.method(dbus_interface="org.freedesktop.NetworkManagerInfo",
                         in_signature="oosib")
                         #out_signature="isi") varies
    def getKeyForNetwork(self, dev, net, ssid, attempt, newkey):
        print "GKFN", dev, net, ssid, attempt, bool(newkey)
        if newkey:
            m = "Cannot ask for key"
            print m
            raise dbus.exceptions.DBusException(m)

        snet = opath_unescape(net[net.rfind("/")+1 : ]) # only stuff after /
        c = self.GetByNet(snet)
        if c != None:
            return c.getKeyForNetwork()
        print "Oops, could not getKeyForNetwork " + net

    @dbus.service.method(dbus_interface="org.freedesktop.NetworkManagerInfo",
                         out_signature='')
                         #in_signature="sbs isi", varies
    def updateNetworkInfo(self, ssid, automatic, bssid, *security):
        print "Connected successfully"
        return
        print "UNI"
        print " ssid:", ssid
        print " automatic:", bool(automatic)
        print " bssid:", bssid
        print " security:", security


    def GetByNet(self, net_name):
        "Returns connection, or None"
        for c in self.conns:
            if c.isNet(net_name):
                return c
        return None


# server analog of cConnection
class Connection(dbus.service.Object):
    def __init__(self, opath, conmap):
        dbus.service.Object.__init__(self, bus, opath)
        self.settings = cSettings(conmap)

    @dbus.service.method(dbus_interface='org.freedesktop.NetworkManagerSettings.Connection',
                         sender_keyword='sender',
                             in_signature='', out_signature='a{sa{sv}}')
    def GetSettings(self, sender):
        #print "Getting settings:", self. __dbus_object_path__
#        return self.settings.ConMap()
# grr, censoring secrets makes NM complain!?
        # bnc#479566#c3: Until I figure out how to make it work with
        # censored secrets, only pass the settings to the same user.
        sender_uid = bus.get_unix_user(sender)
        if sender_uid != 0 and sender_uid != os.geteuid():
            e = "User %u is not permitted to read the settings" % sender_uid
            print e
            raise dbus.exceptions.DBusException(e) # could do NM_SETTINGS_ERROR_* instead
        return self.settings.conmap

    @dbus.service.method(dbus_interface='org.freedesktop.NetworkManagerSettings.Connection.Secrets',
                             in_signature='sasb', out_signature='a{sa{sv}}')
    def GetSecrets(self, tag, hints, ask):
        # FIXME respect args
        print "Getting secrets:", self.__dbus_object_path__
        return self.settings.SecMap()

    @dbus.service.method(dbus_interface='org.freedesktop.NetworkManagerSettings.Connection',
                             in_signature='', out_signature='s')
    def ID(self):
        return self.settings.ID()

    def Ssid(self):
        return self.settings.Ssid()

    def isNet(self, net_name):
        return self.settings.isNet(net_name)

class Connection_06(Connection):
    def __init__(self, opath, conmap):
        dbus.service.Object.__init__(self, bus, opath)
        #print "C6", conmap
        self.settings = cSettings(conmap)

    # dbus.service.method
    def getNetworkProperties(self):
        # essid, timestamp, ?, bssids, we_cipher, ?, ...
        # we_cipher=16: i wep_auth_algorithm
        # we_cipher=0:  i wpa_psk_key_mgt, i wpa_psk_wpa_version
        ssid = ssid_str(self.settings.Ssid())
        time = self.settings.Timestamp() # last sucessfully connected? seen?
        trusted = self.settings.Trusted()
        bssids = dbus.Array(self.settings.SeenBssids(), signature="s")
        r = [ssid, time, trusted, bssids]
        security = self.getKeyForNetwork("fake key")
        r.extend(security)
        return tuple(r)

    # dbus.service.method
    def getKeyForNetwork(self, fake="no"):
        if fake == "no":
            key = self.settings.Key()
        else:
            key = ""

        # security
        cip = self.settings.WeCipher()
        if cip == NM_AUTH_TYPE_NONE:
            security = tuple([cip])
        elif cip == NM_AUTH_TYPE_WEP40 or cip == NM_AUTH_TYPE_WEP104:
            wep_auth_algorithm = self.settings.WepAuthAlgorithm()
            security = (cip, key, wep_auth_algorithm)
        elif cip == NM_AUTH_TYPE_WPA_PSK_AUTO or cip == NM_AUTH_TYPE_TKIP or \
                cip == NM_AUTH_TYPE_CCMP:
            wpa_psk_key_mgt = self.settings.PskKeyMgt()
            wpa_psk_wpa_version = self.settings.PskWpaVersion()
            security = (cip, key, wpa_psk_key_mgt, wpa_psk_wpa_version)
        elif cip == NM_AUTH_TYPE_WPA_EAP:
            security = tuple([cip]) # TODO more...
        elif cip == NM_AUTH_TYPE_LEAP:
            security = tuple([cip]) # TODO more...
        return security



class Monitor(MonitorBase):
    def __init__(self, bus):
        MonitorBase.__init__(self, bus)

        self.watch(
            self.propc_h,
            dbus_interface="org.freedesktop.NetworkManager.Device.Wireless",
            signal_name="PropertiesChanged")
        self.watch(
            self.propc_h,
            dbus_interface="org.freedesktop.NetworkManager.AccessPoint",
            signal_name="PropertiesChanged")

        self.ignore("org.freedesktop.Hal.Device", "PropertyModified")
        self.ignore("fi.epitest.hostap.WPASupplicant.Interface", "ScanResultsAvailable")
        self.ignore("com.redhat.PrinterSpooler", "QueueChanged")
        self.ignore("org.freedesktop.NetworkManager", "StateChange") # deprecated
        self.watch(self.nm_sc_h, "org.freedesktop.NetworkManager", "StateChanged")
        self.watch(self.wpas_isc_h, "fi.epitest.hostap.WPASupplicant.Interface", "StateChange")
        self.watch(self.nmd_sc_h, "org.freedesktop.NetworkManager.Device", "StateChanged")
        self.watch(self.bus_noc_h, "org.freedesktop.DBus", "NameOwnerChanged")

    def bus_noc_h(self, *args, **kwargs):
        (name, old, new) = args
        if new == "":
            new = "gone"
        else:
            new = "at " + new
        print "\tBUS NOC\t%s %s" % (name, new)

    def wpas_isc_h(self, *args, **kwargs):
        opath = kwargs["path"]
        (new, old) = args
        print "\tWPAS %s\t(%s, was %s)" % (new, opath, old.lower())

    def nmd_sc_h(self, *args, **kwargs):
        opath = kwargs["path"]
        (new, old, reason) = args
        news = cDevice_07.NM_DEVICE_STATE[new]
        olds = cDevice_07.NM_DEVICE_STATE[old]
        reasons = ""
        if reason != 0:
            reasons = "reason %d" % reason
        print "\tDevice State %s\t(%s, was %s%s)" % (news, opath, olds.lower(), reasons)

    def nm_sc_h(self, *args, **kwargs):
        s = args[0]
        ss = cNM.NM_STATE[s]
        print "\tNM State:", ss

    def propc_h(self, *args, **kwargs):
        opath = kwargs["path"]
        props = args[0]
        for k, v in props.iteritems():
            if k == "Strength":
                v = "%u" % v
            line = "\tPROP\t%s\t%s\t(%s)" % (k, v, opath)
            print line

# main

fail = False

op = OptionParser(version="%prog " + VERSION)
op.add_option("-d", "--dev",
              action="store_true", default=False,
              help="list devices")
op.add_option("-c", "--actcon",
              action="store_true", default=False,
              help="list active connections")
op.add_option("-u", "--usrcon",
              action="store_true", default=False,
              help="list user connection settings (can CRASH nm-applet)")
op.add_option("-s", "--syscon",
              action="store_true", default=False,
              help="list system connection settings")
op.add_option("-a", "--ap",
              action="store_true", default=False,
              help="list found access points")
op.add_option("-n", "--nets",
              action="store_true", default=False,
              help="list found wireless networks")
# TODO http://docs.python.org/lib/optparse-adding-new-types.html
op.add_option("-w", "--wifi",
              choices=["0","1","off","on","no","yes","false","true"],
              metavar="BOOL",
              help="enable or disable wireless")
op.add_option("-o", "--online",
              choices=["0","1","off","on","no","yes","false","true"],
              metavar="BOOL",
              help="enable or disable network at all")

op.add_option("--activate-connection",
              help="raw API: activate the KIND(user/system) connection CON on device DEV using AP",
              metavar="[KIND],CON,DEV,[AP]")
op.add_option("-C", "--connect",
              help="connect to a wireless network NET (using knetworkmanagerrc or the key options below)",
              metavar="NET")
op.add_option("--unprotected",
              action="store_true", default=False,
              help="network does not require a key")
op.add_option("--wep-hex",
              metavar="KEY",
              help="use this WEP key of 26 hex digits")
op.add_option("--wep-pass",
              metavar="KEY",
              help="use this WEP passphrase")
op.add_option("--wpa-psk-hex",
              metavar="KEY",
              help="use this WPA key of 64 hex digits")
op.add_option("--wpa-pass",
	      metavar="KEY",
	      help="use this WPA passphrase")
op.add_option("-m", "--monitor",
              action="store_true", default=False,
              help="loop to show dbus signals")


(options, args) = op.parse_args()

if options.ap:
    options.dev = True
if options.monitor:
    LOOP = True


nmp = '/org/freedesktop/NetworkManager'
try:
    nm = make_nm(nmp)
except dbus.exceptions.DBusException, e:
    print "NetworkManager is not running or running as an other user"
    fail = True
if options.dev or options.actcon:
    nm.Dump()

true_choices =  ["1", "on", "yes", "true"]
if options.wifi != None:
    nm.SetWifiEnabled(options.wifi in true_choices)
if options.online != None:
    nm.SetOnline(options.online in true_choices)

if options.nets:
    nm.ListNets()

if options.syscon:
    print "SYSTEM Connections"
    if nm.Api() == "06":
        print "Cannot do that with NM 0.6"
        fail = True
    else:
        ss = cApplet(SSC, '/org/freedesktop/NetworkManagerSettings')
        ss.Dump()

if options.usrcon:
    print "USER Connections"
    try:
        if nm.Api() == "06":
            us = cApplet_06(NMIC, "/org/freedesktop/NetworkManagerInfo")
        else:
            us = cApplet(USC, '/org/freedesktop/NetworkManagerSettings')
        us.Dump()
    except dbus.exceptions.DBusException, e:
        print e
        #if e.get_dbus_name() == "org.freedesktop.DBus.Error.ServiceUnknown":
        print "Applet is not running"
        fail = True

nmo = bus.get_object(NMC, nmp)
nmi = dbus.Interface(nmo, NMI)

def service_pid(name):
    DBS = 'org.freedesktop.DBus'
    DBI = DBS
    dbo = bus.get_object(DBS, '/')
    dbi = dbus.Interface(dbo, DBI)
    owner = dbi.GetNameOwner(name)
    pid = dbi.GetConnectionUnixProcessID(owner)
    return pid

# TODO UserSettings_06
if options.connect != None:
    if nm.Api() == "06":
        name = NMIC
    else:
        name = USC
    brn = bus.request_name(name, _dbus_bindings.NAME_FLAG_DO_NOT_QUEUE)
    if brn == _dbus_bindings.REQUEST_NAME_REPLY_EXISTS:
        print "Could not provide settings service, another applet is running (pid %s)" % service_pid(name)
        sys.exit(1)
    cfg = ConfigParserKNM()
    if nm.Api() == "06":
        us = UserSettings_06("/org/freedesktop/NetworkManagerInfo",
                             cfg.ConMaps())
    else:
        us = UserSettings("/org/freedesktop/NetworkManagerSettings",
                      cfg.ConMaps())

def Connect(wanted_net):  # any. or take arg. net is config name or ssid name
    #  ... in general, look for string in all config data. ssid for wifi, whatever for dialup
    # TODO also respect autoconnect

    # ActivateConn wants setting device ap; can find device from ap? ap is "specific" for wifi devices
    #print "Connection wanted to", wanted_net
    found_con = found_ap = found_dev = None
    for dev in nm.Devices():
	for ap in dev.APs():
	    if wanted_net == ap.Ssid():
		found_ap = ap
		found_dev = dev
		break # FIXME both loops
    found_con = us.GetByNet(wanted_net)
    if found_ap == None:
	print "No AP found with SSID", wanted_net
        return False
    if found_con == None:
        print "No settings for net %s, assuming no key is needed" % wanted_net
        c = mkconmap_wifi(wanted_net)
        found_con = us.addCon(c)
    nm.ActivateConnection(found_con, found_dev, found_ap) # TODO async
    # TODO run loop, exit it when we have serviced the required calls
    return True

if options.connect != None:
    if options.unprotected:
        c = mkconmap_wifi(options.connect)
        us.addCon(c)
    if options.wep_hex != None:
        c = mkconmap_wep(options.connect, options.wep_hex)
        us.addCon(c)
    if options.wep_pass != None:
        c = mkconmap_wep_pass(options.connect, options.wep_pass)
        us.addCon(c)
    if options.wpa_psk_hex != None:
        c = mkconmap_psk(options.connect, options.wpa_psk_hex)
        us.addCon(c)
    if options.wpa_pass != None:
	c = mkconmap_psk(options.connect, options.wpa_pass)
        us.addCon(c)
    nm.WatchState()
    if Connect(options.connect):
        LOOP = True
    else:
        fail = True

if options.activate_connection != None:
    (svc, conpath, devpath, appath) = options.activate_connection.split(',')
    if svc == "" or svc == "user":
        svc = USC
    elif svc == "system":
        svc = SSC

    if devpath == "":
        TODO
    if appath == "":
        appath = "/"
    nm.WatchState()
    nm.nmi.ActivateConnection(svc, conpath, devpath, appath,
                              reply_handler=nm.silent_handler,
                              error_handler=nm.err_handler,
                              )
    LOOP = True

if options.monitor:
    m = Monitor(bus)

def loop():
    loop = gobject.MainLoop()
    try:
        loop.run()
    except:
        print "Loop exited"

if LOOP:
    loop()

if fail:
    sys.exit(1)
