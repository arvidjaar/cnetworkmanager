#! /usr/bin/python
# cnetworkmanager: Command Line Interface for NetworkManager
# by: http://en.opensuse.org/User:Mvidner
# license: http://www.gnu.org/licenses/gpl-2.0.html or later

VERSION = "0.5.1"
print "cnetworkmanager %s - Command Line Interface for NetworkManager" % VERSION

norpm = False
import sys
import os
import ConfigParser             # knm config
from optparse import OptionParser
try:
    import dbus
    import dbus.service
    import _dbus_bindings
except:
    print "Install python-1-dbus.rpm or python-dbus.deb"
    norpm = True
import xml.dom.minidom
try:
    import gobject
except:
    # todo - only if loop wanted
    print "Install python-gobject2.rpm or python-gobject.deb"
    norpm = True
# python-gnome.rpm has gconf for nm-applet...
if norpm:
    sys.exit(1)

from dbus.mainloop.glib import DBusGMainLoop
DBusGMainLoop(set_as_default=True)

LOOP = False

bus = dbus.SystemBus()

# FOOC = connection (service) string
# FOOI = interface string
# fooo = object
# fooi = interface
# foopi = property interface
NMC = 'org.freedesktop.NetworkManager'
NMI = NMC
PI = 'org.freedesktop.DBus.Properties'
SSC = "org.freedesktop.NetworkManagerSystemSettings"
USC = "org.freedesktop.NetworkManagerUserSettings"

def introspect(obj):
    ii = dbus.Interface(obj, 'org.freedesktop.DBus.Introspectable')
    print ii.Introspect()

class cNM:
    # TODO: pull them from introspection.xml
    NM_STATE = ["UNKNOWN", "ASLEEP", "CONNECTING", "CONNECTED", "DISCONNECTED",]

    def __init__(self, opath):
	self.opath = opath
        self.nmo = bus.get_object(NMC, self.opath)
        self.nmi = dbus.Interface(self.nmo, NMI)
        self.nmpi = dbus.Interface(self.nmo, PI)

    def Dump0(self):
        "Dumps its own info (not owned objects)."
        pass

    def Dump(self):
        self.Dump0()
        if options.dev:
            for device in self.Devices():
                device.Dump()

        if options.actcon:
            print "Active Connections"
            aconns = self.ActiveConnections()
            for aconn in aconns:
                aconn.Dump()

    def ListNets(self):
        print "Wifi Networks:"
        for dev in self.Devices():
            dev.ListNets()

    def reply_handler(self, opath):
        print "Connected:", opath

    def err_handler(self, *args):
        print "ERR:", args

    def silent_handler(self, *args):
        pass
        print "BOO!:", args

    def quitter_handler(self, *args):
        # exit the loop that runs only because of us
        print "padla"
        sys.exit(0)

    def ActivateConnection(self, conn, device, ap):
        # passing *_handler makes the call asynchronous
        self.nmi.ActivateConnection(USC,
                                    conn.__dbus_object_path__,
                                    device.opath,
                                    ap.opath,
                                    reply_handler=self.reply_handler,
                                    error_handler=self.err_handler,
                                    )

def make_nm(opath):
    "Detects NM version and chooses appropriate class"

    nmo = bus.get_object(NMC, opath)
    nmi = dbus.Interface(nmo, NMI)
    try:
        dummy = nmi.getDevices()
        return cNM_06(opath)
    except dbus.exceptions.DBusException:
        return cNM_07(opath)

class cNM_06(cNM):
    def SetWifiEnabled(self, v):
        # TODO: async call, catch the state signal and exit
        # weird: synchronous call works, but times out
        # asynchronous call does not work
        self.nmi.setWirelessEnabled(v,
                                    reply_handler=self.quitter_handler,
                                    error_handler=self.quitter_handler)
        global LOOP
        LOOP = True

    def SetOnline(self, v):
        self.nmi.sleep(not v,
                                    reply_handler=self.quitter_handler,
                                    error_handler=self.quitter_handler)
        global LOOP
        LOOP = True

    def Dump0(self):
        print "State:", self.NM_STATE[self.nmi.state()]
        (we, whe) = self.nmi.getWirelessEnabled()
        print "Wifi enabled:", bool(we)
        print "Wifi HW enabled:", bool(whe)
        try:
            dup = self.nmi.getDialup()
        except dbus.exceptions.DBusException, e:
            if e.get_dbus_name() == "org.freedesktop.NetworkManager.NoDialup":
                dup = []
        print "Dialup:", dup

    def Devices(self):
        opaths = self.nmi.getDevices()
        return map(cDevice_06, opaths)

    def ActiveConnections(self):
        return []               # at most one active connection, FIXME find it


class cNM_07(cNM):
    def SetWifiEnabled(self, v):
        self.nmpi.Set(NMI, "WirelessEnabled", v)

    def SetOnline(self, v):
        self.nmi.Sleep(not v)

    def Dump0(self):
        print "State:", self.NM_STATE[self.nmpi.Get(NMI, "State")]
        print "Wifi enabled:", self.nmpi.Get(NMI, "WirelessEnabled")
        print "Wifi HW enabled:", self.nmpi.Get(NMI, "WirelessHardwareEnabled")

    def Devices(self):
        opaths = self.nmi.GetDevices()
        return map(cDevice_07, opaths)

    def ActiveConnections(self):
        aconns = self.nmpi.Get(NMI, "ActiveConnections")
        return map(cActiveConnection, aconns)



class cActiveConnection:
    def __init__(self, opath):
        self.opath = opath

    def Dump(self):
       print self.opath
       co = bus.get_object(NMC, self.opath)
       copi = dbus.Interface(co, PI)
       for P in ["ServiceName", "Connection", "SharedServiceName", "SharedConnection", "SpecificObject",]:
           print "  %s: %s" % (P, copi.Get(NMI, P))
       devs = copi.Get(NMI, "Devices")
       print "  Devices:"
       for dev in devs:
           print "  ", dev
   
def bitmask_str(map, value):
    ret = []
    for mask in sorted(map.keys()):
        if value & mask: ret.append(map[mask])
    return ",".join(ret)


class cDevice:
    def __init__(self, opath):
        self.opath = opath
        self.devo = bus.get_object(NMC, self.opath)
        self.devi = dbus.Interface(self.devo, NMI + ".Device")
        self.devpi = dbus.Interface(self.devo, PI)
        self.dt = None
        self.DeviceType0()

    DEVICE_TYPE = ["UNKNOWN", "802_3_ETHERNET", "802_11_WIRELESS",
                   "GSM", "CDMA",]

    def DeviceType(self):
        return self.DEVICE_TYPE[self.DeviceType0()]

    def ip_str(self, i32):
        ret = []
        ret.append("%d" % (i32 % 256))
        i32 /= 256
        ret.append("%d" % (i32 % 256))
        i32 /= 256
        ret.append("%d" % (i32 % 256))
        i32 /= 256
        ret.append("%d" % (i32 % 256))
        i32 /= 256
        return ".".join(ret)

    def DumpIp4Config(self, opath):
        print "   Ip4Config:", opath
        o = bus.get_object(NMC, opath)
        pi = dbus.Interface(o, PI)
        try:
            for P in ["Address", "Netmask", "Broadcast", "Gateway",]: # beta2?
                print "    %s: %s" % (P, self.ip_str(pi.Get(NMI, P)))
        except:
            print "    Addresses:"
            addrs = pi.Get(NMI, "Addresses")
            for addr in addrs:
                print "     %s/%s via %s" %  tuple(map(self.ip_str, addr))
        hn = pi.Get(NMI, "Hostname")
        print "    Hostname:", hn
        nss = pi.Get(NMI, "Nameservers")
        print "    Nameservers:", " ".join(map(self.ip_str, nss))
        doms = pi.Get(NMI, "Domains")
        print "    Domains:", " ".join(doms)
        nisd = pi.Get(NMI, "NisDomain")
        print "    NisDomain:", nisd
        niss = pi.Get(NMI, "NisServers")
        print "    NisServers:", " ".join(map(self.ip_str, niss))

    NM_DEVICE_CAP = {1: "NM_SUPPORTED", 2: "CARRIER_DETECT", 4: "SCANNING", }

    
    def Dump(self):
        print "Device:", self.opath


    IW_MODE = ["AUTO", "ADHOC", "INFRA", "MASTER",
               "REPEAT", "SECOND", "MONITOR",]

    def ListNets(self):
            for ap in self.APs():
                ap.ListNets()

# mixin
class cDeviceEth:
    def APs(self):
        return []

class cDevice_06(cDevice):
    def DeviceType0(self):
        if self.dt is None:
            self.dt = self.devi.getProperties()[2]
            if self.dt == 1:
                self.__class__ = cDeviceEth_06
            elif self.dt == 2:
                self.__class__ = cDeviceWifi_06
        return self.dt

    NM_ACT_STAGE = [
        "UNKNOWN", "DEVICE_PREPARE", "DEVICE_CONFIG", "NEED_USER_KEY",
        "IP_CONFIG_START", "IP_CONFIG_GET", "IP_CONFIG_COMMIT",
        "ACTIVATED", "FAILED", "CANCELLED", ]

    def Dump(self):
        cDevice.Dump(self)
        print "  Driver:", self.devi.getDriver()
        props = self.devi.getProperties() # osusb ussss sssii biuus as
        print "  Self:", props[0]         # o
        print "  Interface:", props[1]    # s
        print "  Type:", self.DEVICE_TYPE[props[2]] # u
        print "  UDI:", props[3]                    # s
        print "  Active:", bool(props[4])           # b
        print "  Activation Stage:", self.NM_ACT_STAGE[props[5]] # u
        print "  IP:", props[6]                     # s
        print "  Mask:", props[7]                   # s
        print "  Bcast:", props[8]                  # s
        print "  HwAddress:", props[9]              # s
        print "  GW:", props[10]                    # s
        print "  NS1:", props[11]                   # s
        print "  NS2:", props[12]                   # s
        self.DumpMore()

class cDeviceEth_06(cDevice_06, cDeviceEth):
    def DumpMore(self):
        props = self.devi.getProperties() # osusb ussss sssii biuus as
        print "  Link Active:", bool(props[15])     # b
        print "  Speed:", props[16]                 # i
        print "  Generic Capabilities:", bitmask_str(self.NM_DEVICE_CAP, props[17])  # u

class cDeviceWifi_06(cDevice_06):
    NM_802_11_CAP = {
	0x00000001: "PROTO_NONE",
	0x00000002: "PROTO_WEP",
	0x00000004: "PROTO_WPA",
	0x00000008: "PROTO_WPA2",
	0x00000010: "RESERVED1",
	0x00000020: "RESERVED2",
	0x00000040: "KEY_MGMT_PSK",
	0x00000080: "KEY_MGMT_802_1X",
	0x00000100: "RESERVED3",
	0x00000200: "RESERVED4",
	0x00000400: "RESERVED5",
	0x00000800: "RESERVED6",
	0x00001000: "CIPHER_WEP40",
	0x00002000: "CIPHER_WEP104",
	0x00004000: "CIPHER_TKIP",
	0x00008000: "CIPHER_CCMP",
        }

    def APs(self):
        self.wdevi = dbus.Interface(self.devo, NMI + ".Device.Wireless")
        aps = self.devi.getProperties()[20]
        return map(cAP_06, aps)

    def DumpMore(self):
        props = self.devi.getProperties() # osusb ussss sssii biuus as
        print "  Mode:", self.IW_MODE[props[13]]    # i
        print "  Strength:", props[14]              # i
        print "  Link Active:", bool(props[15])     # b
        print "  Speed:", props[16]                 # i
        print "  Generic Capabilities:", bitmask_str(self.NM_DEVICE_CAP, props[17])  # u
        print "  Capabilities:", bitmask_str(self.NM_802_11_CAP, props[18]) # u
        print "  Current net:", props[19]           # s
        nets = props[20]                            # as
        print "  Seen nets:", " ".join(nets)
        if options.ap:
            print "  Access Points"
            for ap in self.APs():
                ap.Dump()

class cDevice_07(cDevice):
    def DeviceType0(self):
        if self.dt is None:
            self.dt = self.devpi.Get(NMI, "DeviceType")
            if self.dt == 1:
                self.__class__ = cDeviceEth_07
            elif self.dt == 2:
                self.__class__ = cDeviceWifi_07
        return self.dt

    NM_DEVICE_STATE = [
        "UNKNOWN", "UNMANAGED", "UNAVAILABLE", "DISCONNECTED", "PREPARE",
        "CONFIG", "NEED_AUTH", "IP_CONFIG", "ACTIVATED", "FAILED",]

    def Dump(self):
        cDevice.Dump(self)

        # "Ip4Config", only for NM_DEVICE_STATE_ACTIVATED
        for P in ["Udi", "Interface", "Driver",]:
            print "  %s: %s" % (P, self.devpi.Get(NMI, P))
        addr = self.devpi.Get(NMI, "Ip4Address")
        print "  Ip4Address:", self.ip_str(addr)
        caps = self.devpi.Get(NMI, "Capabilities")
        print "  Capabilities:", bitmask_str(self.NM_DEVICE_CAP, caps)
        state = self.NM_DEVICE_STATE[self.devpi.Get(NMI, "State")]
        print "  Dev State:", state
        if state == "ACTIVATED":
            self.DumpIp4Config(self.devpi.Get(NMI, "Ip4Config"))

        dt = self.DeviceType()
        print "  Dev Type:", dt
        self.DumpMore()

class cDeviceEth_07(cDevice_07, cDeviceEth):
    def DumpMore(self):
        for P in ["HwAddress", "Speed", "Carrier"]:
            print "  %s: %s" % (P, self.devpi.Get(NMI, P))

class cDeviceWifi_07(cDevice_07):
    NM_802_11_DEVICE_CAP = {1:"CIPHER_WEP40", 2:"CIPHER_WEP104",
                            4:"CIPHER_TKIP", 8:"CIPHER_CCMP",
                            16:"WPA", 32:"RSN",}

    def APs(self):
        self.wdevi = dbus.Interface(self.devo, NMI + ".Device.Wireless")
        aps = self.wdevi.GetAccessPoints()
        return map(cAP_07, aps)

    def DumpMore(self):
        print "  Dev Mode:", self.IW_MODE[self.devpi.Get(NMI, "Mode")]
        wcaps = self.devpi.Get(NMI, "WirelessCapabilities")
        print "  Wifi Capabilities:", bitmask_str(self.NM_802_11_DEVICE_CAP, wcaps)
        for P in ["HwAddress", "Bitrate", "ActiveAccessPoint"]:
            print "  %s: %s" % (P, self.devpi.Get(NMI, P))
        if options.ap:
            print "  Access Points"
            for ap in self.APs():
                ap.Dump()
    
"""An AP found around us"""
class cAP:
    def __init__(self, opath):
        self.opath = opath
        self.apo = bus.get_object(NMC, self.opath)
        self.appi = dbus.Interface(self.apo, PI)
        # for _06
        self.devi = dbus.Interface(self.apo, NMI + ".Devices")

    NM_802_11_AP_FLAGS = {1: "PRIVACY",}

    NM_802_11_AP_SEC = {
        1: "PAIR_WEP40", 2: "PAIR_WEP104", 4: "PAIR_TKIP", 8: "PAIR_CCMP",
        16: "GROUP_WEP40", 32: "GROUP_WEP104", 64: "GROUP_TKIP",
        128: "GROUP_CCMP", 256: "KEY_MGMT_PSK", 512: "KEY_MGMT_802_1X",}

    def ListNets(self, marker = " "):
        # TODO *mark current
        mbr = self.Mbr() / 1024 # 07 1000, 06 1024?
        priv_s = self.PrivS()
        print "%s%3d: %s (%dMb%s)" % (marker, self.Strength(), self.Ssid(), mbr, priv_s)

class cAP_06(cAP):
    def Mbr(self, props=None):
        if props is None:
            props = self.devi.getProperties()
        return props[5]

    
    def PrivS(self):
        props = self.devi.getProperties()
        caps_s = bitmask_str(cDeviceWifi_06.NM_802_11_CAP, props[7]) + ","
        priv_s = ""
        if caps_s.find("PROTO_WEP,") != -1:
            priv_s += " WEP"
        if caps_s.find("PROTO_WPA,") != -1:
            priv_s += " WPA"
        if caps_s.find("PROTO_WPA2,") != -1:
            priv_s += " WPA2"
        if caps_s.find("KEY_MGMT_802_1X,") != -1:
            priv_s += " Enterprise"
        return priv_s

    def Strength(self, props=None):
        if props is None:
            props = self.devi.getProperties()
        return props[3]

    def Ssid(self, props=None):
        if props is None:
            props = self.devi.getProperties()
        return props[1]


    def Dump(self):
        props = self.devi.getProperties() # ossid iiib
        print "   Self:", props[0]
        print "    Ssid:", self.Ssid(props)
        print "    HwAddress:", props[2]
        print "    Strength:", self.Strength(props)
        print "    Frequency:", props[4]
        print "    MaxBitrate:", self.Mbr(props)
        print "    AP Mode:", cDevice.IW_MODE[props[6]]
        print "    Capabilities:", bitmask_str(cDeviceWifi_06.NM_802_11_CAP, props[7])
        print "    Broadcast:", props[8]
        
class cAP_07(cAP):
    def Mbr(self):
        return self.appi.Get(NMI, "MaxBitrate")

    def PrivS(self):
        priv = self.appi.Get(NMI, "Flags") != 0
        wpa = self.appi.Get(NMI, "WpaFlags") != 0
        wpa2 = self.appi.Get(NMI, "RsnFlags") != 0
        priv_s = ""
        if priv:
            if not wpa and not wpa2:
                priv_s = priv_s + " WEP"
            if wpa:
                priv_s = priv_s + " WPA"
            if wpa2:
                priv_s = priv_s + " WPA2"
        return priv_s

    def Strength(self):
        return int(self.appi.Get(NMI, "Strength"))

    def ssid_str(noself, array):
        s = ""
        for b in array:
            s = s + ("%c" % b)
        return s

    def Ssid(self):
        return self.ssid_str(self.appi.Get(NMI, "Ssid"))

    def Dump(self):
        print "  AP:", self.opath
        print "    Ssid:", self.Ssid()
        for P in ["Frequency", "HwAddress", "MaxBitrate",]:
            print "    %s: %s" % (P, self.appi.Get(NMI, P))
        print "    Strength:", self.Strength()
        print "    AP Mode:", cDevice.IW_MODE[self.appi.Get(NMI, "Mode")]
        print "    AP Flags:", bitmask_str(self.NM_802_11_AP_FLAGS,
                                           self.appi.Get(NMI, "Flags"))
        print "    AP WPA Flags:", bitmask_str(self.NM_802_11_AP_SEC,
                                               self.appi.Get(NMI, "WpaFlags"))
        print "    AP RSN Flags:", bitmask_str(self.NM_802_11_AP_SEC,
                                               self.appi.Get(NMI, "RsnFlags"))
    
# this is the client side of the applet; see also UserSettings
class cApplet:
    def __init__(self, svc, opath):
        self.svc = svc
        self.opath = opath
        self.so = bus.get_object(self.svc, self.opath)
        self.si = dbus.Interface(self.so, 'org.freedesktop.NetworkManagerSettings')

    def isSystem(self):
        return self.svc == SSC;

    def Dump(self):
        for conn in self.Connections():
            conn.Dump()
        if self.isSystem():
            self.DumpSystem()

    def DumpSystem(self):
        sspi = dbus.Interface(self.so, PI)
        print "Unmanaged Devices"
        umds = sspi.Get(NMI, "UnmanagedDevices")
        for umd in umds:
            print " ", umd
           #  dump_settings_conn(svc, conn) umd?


    def myConnection(self, opath):
        return cConnection(self.svc, opath)

    def Connections(self):
        opaths = self.si.ListConnections()
        return map(self.myConnection, opaths)

class cConnection:
    def __init__(self, svc, opath):
        self.svc = svc
        self.opath = opath
        self.co = bus.get_object(self.svc, self.opath)
        self.ci = dbus.Interface(self.co, 'org.freedesktop.NetworkManagerSettings.Connection')

    def Dump(self):
       print "Conn:", self.opath
       print " Id:", self.ci.GetID()
       settings = self.Settings()
       settings.Dump()

       si = dbus.Interface(self.co, 'org.freedesktop.NetworkManagerSettings.Connection.Secrets')
       security = settings.Security()
       if security != "":
           print " SECRETS:", security
           # TODO merge them
           secrets = cSettings(si.GetSecrets(security,[],False))
           secrets.Dump()

    def Settings(self):
        return cSettings(self.ci.GetSettings())


class cSettings:
    def __init__(self, conmap):
        self.conmap = conmap

    def Type(self):
        return self.conmap["connection"]["type"]

    def GetID(self):
        return self.conmap["connection"]["id"]

    def Security(self):
        try:
            return self.conmap[self.Type()]["security"]
        except KeyError:
            return ""

    def isNet(self, net_name):
        # FIXME also ssid ...
        return self.GetID() == net_name

    # FIXME check spec/NM what to censor
    secrets = dict.fromkeys(["wep-key0", "psk"])

    def ConMap(self):
        "For GetSettings: censor secrets."

        cm = dict()
        for n1, v1 in self.conmap.iteritems():
            cm[n1] = dict()
            for n2, v2 in v1.iteritems():
                cv2 = v2
                if self.secrets.has_key(n2):
                    cv2 = ""
                cm[n1][n2] = cv2
        return cm

    def SecMap(self):
        "For GetSecrets: only secrets."
        s = self.Security()
        r = {
            s: self.conmap[s]
            }
        print "SECMAP", r
        return r

    def Dump(self):
        for n1, v1 in self.conmap.iteritems():
            print " ",n1
            for n2, v2 in v1.iteritems():        
                print "   %s: %s" % (n2, v2)

# just an example, unused  now
hardwired_conmaps = [
    {
        "connection": {
            "id": "onenet",
            "type": "802-11-wireless",
            },
        "802-11-wireless": {
            "ssid": dbus.ByteArray("onenet"),
            "mode": "infrastructure",
            "security": "802-11-wireless-security",
            },
        #  ipv4
        #   method: dhcp
        "802-11-wireless-security": {
            "key-mgmt": "wpa-psk",
            "wep-tx-keyidx": 0,
            "psk": "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", # CENSORED
            },
        },
    {
        'connection': {
            'id': 'frogs',
            'type': '802-11-wireless',
            },
        '802-11-wireless': {
            'ssid': dbus.ByteArray('frogs'),
            'mode': 'infrastructure',
            'security': '802-11-wireless-security',
            },
        '802-11-wireless-security': {
            'key-mgmt': 'none',
            'wep-tx-keyidx': 0,
            'wep-key0': 'aaaaaaaaaaaaaaaaaaaaaaaaaa', # CENSORED
            },
        },
    ]

class UserSettings_06:
    @dbus.service.method(dbus_interface="org.freedesktop.NetworkManagerInfo",
                         in_signature="i", out_signature='as')
    def getNetworks(self, i):
        return ["frogs"]        # FIXME

    @dbus.service.method(dbus_interface="org.freedesktop.NetworkManagerInfo",
                         in_signature="", out_signature='ao') # out??
    def getVpnConnections(self):
        return []               # FIXME

    @dbus.service.method(dbus_interface="org.freedesktop.NetworkManagerInfo",
                         in_signature="si", out_signature='sibasisi')
    # or additional i ???
    def getNetworkProperties(self, net, i):
        # essid, timestamp, ?, bssids, we_cipher, ?, ...
        # we_cipher=16: i wep_auth_algorithm
        # we_cipher=0:  i wpa_psk_key_mgt, i wpa_psk_wpa_version
        return ("frogs", 1213713468, 0, ['00:13:10:06:E3:77'], 16, "", 1)
        return []               # FIXME

    @dbus.service.method(dbus_interface="org.freedesktop.NetworkManagerInfo",
                         in_signature="oosib", out_signature="isi")
    def getKeyForNetwork(self, dev, net, ssid, i, b):
        return (16, "66666666666666666666666666",1) # FIXME

    @dbus.service.method(dbus_interface="org.freedesktop.NetworkManagerInfo",
                         in_signature="sbsisi", out_signature='')
    def updateNetworkInfo(self, ssid, b, ap, i1, secret, i2):
        pass



# server analog of cApplet
class UserSettings(dbus.service.Object):
    # conmaps is a list
    def __init__(self, opath, conmaps):
        dbus.service.Object.__init__(self, bus, opath)
        #print "CONMAPS:", conmaps
        self.conns = map(self.newCon, conmaps)

    counter = 1
    def newCon(self, conmap):
        cpath = "/MyConnection/%d" % self.counter
        self.counter = self.counter + 1
        c = Connection(cpath, conmap)
        self.NewConnection(cpath) # announce it
        return c

    @dbus.service.method(dbus_interface='org.freedesktop.NetworkManagerSettings',
                             in_signature='', out_signature='ao')
    def ListConnections(self):
        return [c.__dbus_object_path__ for c in self.conns]

    #this is for EMITTING a signal, not receiving it
    @dbus.service.signal(dbus_interface='org.freedesktop.NetworkManagerSettings',
                             signature='o')
    def NewConnection(self, opath):
        pass
        #print "signalling newconn:", opath

    def GetByNet(self, net_name):
        "Returns connection, or None"
        for c in self.conns:
            if c.isNet(net_name):
                return c
        return None


# server analog of cConnection
class Connection(dbus.service.Object):
    def __init__(self, opath, conmap):
        dbus.service.Object.__init__(self, bus, opath)
        self.settings = cSettings(conmap)

    @dbus.service.method(dbus_interface='org.freedesktop.NetworkManagerSettings.Connection',
                             in_signature='', out_signature='a{sa{sv}}')
    def GetSettings(self):
        #print "Getting settings:", self. __dbus_object_path__
#        return self.settings.ConMap()
# grr, censoring secrets makes NM complain!?
        return self.settings.conmap

    @dbus.service.method(dbus_interface='org.freedesktop.NetworkManagerSettings.Connection.Secrets',
                             in_signature='sasb', out_signature='a{sa{sv}}')
    def GetSecrets(self, tag, hints, ask):
        # FIXME respect args
        print "Getting secrets:", self.__dbus_object_path__
        return self.settings.SecMap()

    @dbus.service.method(dbus_interface='org.freedesktop.NetworkManagerSettings.Connection',
                             in_signature='', out_signature='s')
    def GetID(self):
        return self.settings.GetID()

    def isNet(self, net_name):
        return self.settings.isNet(net_name)

class ConfigParserKNM:
    "Parse ~/.kde/share/config/knetworkmanagerrc"

    def __init__(self):
        p = ConfigParser.RawConfigParser()
        ok = p.read(os.getenv("HOME") + "/.kde/share/config/knetworkmanagerrc")

        self.conmaps_d = {}
        for s in p.sections():
            path = s.split("_")
            #print path
            if path[0] in ["ConnectionSetting", "ConnectionSecrets"]:
                cid = path[1]
                self.conmaps_d.setdefault(cid, {})
                part = path[2]

                values = {}
                for (n, v) in p.items(s):
                    # WTF, Value_ is transfrmed to value_
                    if n[:6]  == "value_":
                        n = n[6:]
                        v = self.ParseValue(v)
                        values[n] = v
                if len(values) != 0: # empty 802-1x confuses NM!?
                    self.conmaps_d[cid].setdefault(part, {})
                    self.conmaps_d[cid][part].update(**values)
                #print "PARSED", cid, part, values

    def ConMaps(self):
        return self.conmaps_d.values()

    def ParseValue(self, v):
        v = eval('"%s"' % v)    # unescape backslashes
        dom = xml.dom.minidom.parseString(v)
        return self.ParseNode(dom.documentElement)

    def ParseNode(self, n):
        t = n.localName
        if t != "list":
            v = self.NodeText(n)

        if t == "string":
            return v
        elif t == "byte":
            return dbus.Byte(int(v))
        elif t == "bool":
            return v == "true"
        elif t == "int32" or t == "uint32":
            return int(v)
        elif t == "list":
            v = []
            c = n.firstChild
            while c != None:
                if c.localName != None: # whitespace
                    v.append(self.ParseNode(c))
                c = c.nextSibling
            return v

    def NodeText(self, n):
        if n.hasChildNodes():
            return n.firstChild.wholeText
        else:
            return ""

def abbr_signal_handler(*args, **kwargs):
    ifc = kwargs["interface"]
    sig = kwargs["member"]
    opath = kwargs["path"]
    line = "SIG %s: %s.%s%s" % (abbrev(opath,"/"), abbrev(ifc,"."), sig, args)
    print line

class Monitor:
    def __init__(self):
        self.amap = {}
        bus.add_signal_receiver(self.abbr_signal_handler,
                        path_keyword="path",
                        interface_keyword="interface",
                        member_keyword="member")

    def abbr_signal_handler(self, *args, **kwargs):
        ifc = kwargs["interface"]
        sig = kwargs["member"]
        opath = kwargs["path"]
        line = "SIG %s: %s.%s%s" % (self.abbrev(opath,"/"),
                                    self.abbrev(ifc,"."),
                                    sig, args)
        print line

    def abbrev(self, s, sep):
        words = s.split(sep)
        words = map (self.a1, words)
        result = sep.join(words)
        if not self.amap.has_key(s):
            print "ABBR %s is %s" % (result, s)
            self.amap[s] = result
        else:
            if self.amap[s] != result:
                print "ABBR COLLISION %s was %s now %s" % (s, self.amap[s], result)
        return result
    
    def a1(self, s):
        try:
            return s[0]
        except:
            return ""

# main

op = OptionParser(version="%prog " + VERSION)
op.add_option("-d", "--dev",
              action="store_true", default=False,
              help="list devices")
op.add_option("-c", "--actcon",
              action="store_true", default=False,
              help="list active connections")
op.add_option("-u", "--usrcon",
              action="store_true", default=False,
              help="list user connection settings (can CRASH nm-applet)")
op.add_option("-s", "--syscon",
              action="store_true", default=False,
              help="list system connection settings")
op.add_option("-a", "--ap",
              action="store_true", default=False,
              help="list found access points")
op.add_option("-n", "--nets",
              action="store_true", default=False,
              help="list found wireless networks")
# TODO http://docs.python.org/lib/optparse-adding-new-types.html
op.add_option("-w", "--wifi",
              choices=["0","1","off","on","no","yes","false","true"],
              metavar="BOOL",
              help="enable or disable wireless")
op.add_option("-o", "--online",
              choices=["0","1","off","on","no","yes","false","true"],
              metavar="BOOL",
              help="enable or disable network at all")

op.add_option("-C", "--connect",
              help="connect to a wireless network NET (using knetworkmanagerrc)",
              metavar="NET")
op.add_option("-m", "--monitor",
              action="store_true", default=False,
              help="loop to show dbus signals")


(options, args) = op.parse_args()

if options.ap:
    options.dev = True
if options.monitor:
    LOOP = True


nmp = '/org/freedesktop/NetworkManager'
nm = make_nm(nmp)
if options.dev or options.actcon:
    nm.Dump()

true_choices =  ["1", "on", "yes", "true"]
if options.wifi != None:
    nm.SetWifiEnabled(options.wifi in true_choices)
if options.online != None:
    nm.SetOnline(options.online in true_choices)

if options.nets:
    nm.ListNets()

if options.syscon:
    print "SYSTEM Connections"
    ss = cApplet(SSC, '/org/freedesktop/NetworkManagerSettings')
    ss.Dump()

if options.usrcon:
    print "USER Connections"
    try:
        us = cApplet(USC, '/org/freedesktop/NetworkManagerSettings')
        us.Dump()
    except dbus.exceptions.DBusException, e:
        print e
        if e.get_dbus_name() == "org.freedesktop.DBus.Error.ServiceUnknown":
            print "Applet is not running"

nmo = bus.get_object(NMC, nmp)
nmi = dbus.Interface(nmo, NMI)

# TODO UserSettings_06
if options.connect != None:
    brn = bus.request_name(USC, _dbus_bindings.NAME_FLAG_DO_NOT_QUEUE)
    if brn == _dbus_bindings.REQUEST_NAME_REPLY_EXISTS:
        print "Could not provide settings service, another applet is running"
        sys.exit(1)
    cfg = ConfigParserKNM()
    us = UserSettings("/org/freedesktop/NetworkManagerSettings",
                      cfg.ConMaps())

def Connect(wanted_net):  # any. or take arg. net is config name or ssid name
    #  ... in general, look for string in all config data. ssid for wifi, whatever for dialup
    # TODO also respect autoconnect

    # ActivateConn wants setting device ap; can find device from ap? ap is "specific" for wifi devices
    #print "Connection wanted to", wanted_net
    found_con = found_ap = found_dev = None
    for dev in nm.Devices():
	for ap in dev.APs():
	    if wanted_net == ap.Ssid():
		found_ap = ap
		found_dev = dev
		break # FIXME both loops
    found_con = us.GetByNet(wanted_net)
    if found_ap == None:
	print "No AP found with SSID", wanted_net
        return False
    elif found_con == None:
        print "No settings for net", wanted_net
        return False
    else:
	nm.ActivateConnection(found_con, found_dev, found_ap) # TODO async
	# TODO run loop, exit it when we have serviced the required calls
        return True

if options.connect != None:
    if Connect(options.connect):
        LOOP = True

if options.monitor:
    m = Monitor()

def loop():
    loop = gobject.MainLoop()
    try:
        loop.run()
    except:
        print "Loop exited"

if LOOP:
    loop()
