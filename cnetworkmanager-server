#!/usr/bin/python
VERSION = "0.20"

import sys
import dbus
import dbus.service
import _dbus_bindings
from mkconmap import *
from svc_settings import UserSettings

# must be set before we ask for signals
from dbus.mainloop.glib import DBusGMainLoop
DBusGMainLoop(set_as_default=True)
# for calling quit
import gobject
loop = gobject.MainLoop()

from optparse import OptionParser

op = OptionParser(version="%prog " + VERSION)

op.add_option("--unprotected",
              action="store_true", default=False,
              help="network does not require a key")
op.add_option("--wep-hex",
              metavar="KEY",
              help="use this WEP key of 26 hex digits")
op.add_option("--wep-pass",
              metavar="KEY",
              help="use this WEP passphrase")
#op.add_option("--wpa-psk-hex",
#              metavar="KEY",
#              help="use this WPA key of 64 hex digits")
op.add_option("--wpa-pass",
	      metavar="KEY",
	      help="use this WPA passphrase")

(options, args) = op.parse_args()
try:
    ssid = args[0]
except:
    ssid = None

def service_pid(name, bus):
    DBS = 'org.freedesktop.DBus'
    DBI = DBS
    dbo = bus.get_object(DBS, '/')
    dbi = dbus.Interface(dbo, DBI)
    owner = dbi.GetNameOwner(name)
    pid = dbi.GetConnectionUnixProcessID(owner)
    return pid

def request_name(name, bus):
    brn = bus.request_name(name, _dbus_bindings.NAME_FLAG_DO_NOT_QUEUE)
    if brn == _dbus_bindings.REQUEST_NAME_REPLY_EXISTS:
        print "Could not provide service %s on %s, it is already running with pid %s" % (name, bus, service_pid(name, bus))
        return False
    return True

#but what if there is no session bus?
#is it just a convenience and can they start manually?
request_name("net.vidner.CNetworkManagerSettings", dbus.SessionBus())
request_name("org.freedesktop.NetworkManagerUserSettings", dbus.SystemBus()) or sys.exit(1)
us = UserSettings("/org/freedesktop/NetworkManagerSettings", [])

if ssid != None:
    if options.unprotected:
        c = mkconmap_wifi(ssid)
        us.addCon(c)
    if options.wep_hex != None:
        c = mkconmap_wep(ssid, options.wep_hex)
        us.addCon(c)
    if options.wep_pass != None:
        c = mkconmap_wep_pass(ssid, options.wep_pass)
        us.addCon(c)
#    if options.wpa_psk_hex != None:
#        c = mkconmap_psk(ssid, options.wpa_psk_hex)
#        us.addCon(c)
    if options.wpa_pass != None:
	c = mkconmap_psk(ssid, options.wpa_pass)
        us.addCon(c)

# NM upstream knows only the setting dicts, they are constructed by the applets
# This provides a library to construct such dicts
class CNMS(dbus.service.Object):
    def __init__(self, bus, opath):
        super(CNMS, self).__init__(bus, opath)

    @dbus.service.method(
        dbus_interface='org.freedesktop.NetworkManagerSettings.Factory',
#        sender_keyword='sender',
        in_signature='', out_signature='a{sa{sv}}')
    def Wep(self):
        return {}

cnms = CNMS(dbus.SessionBus(), "/net/etc")

try:
    print "Entering mainloop"
    loop.run()
except KeyboardInterrupt:
    print "Loop exited"
# FIXME when to quit? do we know if the conn is no longer needed? be killed with the rest of the system/session? allow being kicked out by another instance?
